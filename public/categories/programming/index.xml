<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on Locus: Richard Careaga</title>
    <link>/categories/programming/</link>
    <description>Recent content in Programming on Locus: Richard Careaga</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 03 May 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/categories/programming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Row collapsing</title>
      <link>/2019/05/03/duplicate-keys-for-multiple-logical-columns/</link>
      <pubDate>Fri, 03 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/05/03/duplicate-keys-for-multiple-logical-columns/</guid>
      <description>Untidy happens It’s not always possible to store everything in a tidy but humongous data store. So, we have things like SQL foreign keys.
Unfortunately, the database may not have been set up with future tidy in mind. Or, database access is only provided through CSV files.
Here’s an example of what can happen. We begin with some basic information, as tidy as we could wish with not too much effort.</description>
    </item>
    
    <item>
      <title>The compiler will tell you what the user cannot</title>
      <link>/2019/01/08/the-compiler-will-tell-you-what-the-user-cannot/</link>
      <pubDate>Tue, 08 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/01/08/the-compiler-will-tell-you-what-the-user-cannot/</guid>
      <description>The compiler will always tell you about source code errors that prevent compiling. It can’t advise you if your code solves the problem that it was supposed to solve, even if you are confident in what that problem is. But have a thought for the user who posed the problem, and keep in mind two famous quotations.
 Thus, programs must be executed for humans to read, only incidentially for machines to execute.</description>
    </item>
    
    <item>
      <title>R and Haskell, meant for each other?</title>
      <link>/2018/11/07/r-and-haskell-meant-for-each-other/</link>
      <pubDate>Wed, 07 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/11/07/r-and-haskell-meant-for-each-other/</guid>
      <description>R has a notoriously steep learning curve. I once moaned that help() needed it’s own help(help), which it does, but did nothing to help me understand the paradigm of function signatures. And why were control loops like for so frowned upon. All sorts of great functionality, but how do you, like program it.
As I progressed in my ability to overcome my underlying lack of grok, I took a dip in Haskell, and discovered the concept of a functional language, essentially everything is \(f(x) = y\) as opposed to an imperative/procedural language – first do this, then do that, then perform some operation on both of them, and then, and then … .</description>
    </item>
    
    <item>
      <title>Deboning simple linear regression output in TensorFlow</title>
      <link>/2018/09/04/deboning-simple-linear-regression-output-in-tensorflow/</link>
      <pubDate>Tue, 04 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/09/04/deboning-simple-linear-regression-output-in-tensorflow/</guid>
      <description>A simple linear regression example in TensorFlow(TM) is given at (https://www.tensorflow.org/tutorials/keras/basic_regression). By default, it produces none of the outputs of linear regression, other than MAE or MSE, on request through a print statement.
Testing set Mean Abs Error: $2788.86 Time spent searching the documentation turned up no references to “intercept”, “coefficient”, “F-statistic”, “t-value,” or “p-value.”
I am only beginning to dip my toes into TensorFlow(TM). I suspect that it exists not so much as a suite of modeling tools so much as a platform to express them in n-dimensional space very efficiently.</description>
    </item>
    
    <item>
      <title>Go Not Considered Harmful</title>
      <link>/2018/09/02/go-not-considered-harmful/</link>
      <pubDate>Sun, 02 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/09/02/go-not-considered-harmful/</guid>
      <description>I had my first exposure to programming in a FORTRAN class with real punchcards, back in the day, before I knew that GOTO was considered harmful. The exposure was brief and left me wondering whether Russian verbs of motion might not be easier to study, after all.
In the years to follow, I ran the occasional canned deck with my datacards through overnight batch queues, but did not return to anything that could be called programming until I acquired an HP-25 calculator with a macro language, followed shortly by an HP-97 with little magnetic strips on which to record them.</description>
    </item>
    
    <item>
      <title>Analytic Data Scientists -- know when to fold &#39;em</title>
      <link>/2018/08/12/analytic-data-scientists-know-when-to-fold-em/</link>
      <pubDate>Sun, 12 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/08/12/analytic-data-scientists-know-when-to-fold-em/</guid>
      <description>In the days of our forebearers, if a tool broke, you were likely to fix it yourself. Long time passing, of course, the shadetree mechanic has been an endangered species. And no one would hire a carpenter who didn’t own his own tools.
I’ve been one to use my own tools. I have to admit to being, at times, cavalier about corporate policies strictly forbidding the use of employee owned computers, at least in the building.</description>
    </item>
    
    <item>
      <title>Newtonian Data Sciences</title>
      <link>/2018/08/06/newtonian-data-sciences/</link>
      <pubDate>Mon, 06 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/08/06/newtonian-data-sciences/</guid>
      <description>Advanced machine learning and AI strike me as deterministic finite state machines with an error term. Properly tuned, the same input should produce much the same output every time. Like Newtonian physics, they can be complicated, but deconstructible into simple components. Like Newtonian physics, as well, they are highly accurate and reliable within their domain.
What happens when we start applying the same tools to complex systems? What are the complex systems of importance that refuse to yield identical results with identical inputs?</description>
    </item>
    
    <item>
      <title>An error message is as much of a question as it is an answer</title>
      <link>/2018/08/05/an-error-message-is-as-much-of-a-question-as-it-is-an-answer/</link>
      <pubDate>Sun, 05 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/08/05/an-error-message-is-as-much-of-a-question-as-it-is-an-answer/</guid>
      <description>A question on datascience.stackexchange asked the reason for a Python syntax error
SyntaxError: can&amp;#39;t assign to literal Another poster had the correct change to fix the error but the explanation didn’t reflect what the OP needed to understand the problem behind the problem, which was failing to be namespace aware – he was trying to perform an operation on an undefined object.
When you find the answer to a question you don’t understand, you can expect to see it again.</description>
    </item>
    
  </channel>
</rss>